/*
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The 
 * first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 */

#include <stdio.h>

#define TEST(func, i, o, a)                                                     \
                o = func(i);                                                    \
                if(o != a)                                                      \
                        printf("! " #func "(%i) returned %i but expected %i\n", \
                                        i, o, a)
                                                                                

int solution(const int X);
int divisor_count(const int X);
void test_sweep();

main()
{
        printf("Euler Problem 12\n");
        test_sweep();
        printf("Answer: %i\n", solution(500));
}

/*
 * Version: 12.07.20 (not complete)
 * Finds the first triangle number with over X factors.
 */
int solution(const int X)
{
        int i;
        int current = 0;
        for(i=1; divisor_count(current) <= X; i++)
                current = i * (i + 1) / 2;
                
        return current;
}

/*
 * Version: 12.07.20 (Generic Smart Readable)
 * Finds the number of factors that X has.
 * Note: Zero means X is not a natural number, Negative means error.
 */
int divisor_count(const int X)
{
        if(X<=0)
                return 0;
        if(X==1)
                return 1;
        
        int current = 0;
        int last;
        int i;
        int count = 0;
        
        for(i = 1; i*i <= X; i++) {
                if((X % i) == 0) {
                        last = current;
                        current = i;
                        //printf("~ current: %i, last: %i, count: %i\n", 
                        //        current, last, count);
                        if(current * current == X)
                                return count * 2 + 1;
                        if(last * current == X)
                                return count * 2;
                        count++;
                }
        }
        
        return count * 2;
}

/*
 * Version: 12.07.20
 * Test divisor_count() and solution()
 */
void test_sweep()
{
        int input;
        int output;
        int answer;
        
        // divisor_count() test
        input = 28;
        answer = 6;
        TEST(divisor_count, input, output, answer);
        input = 80;
        answer = 10;
        TEST(divisor_count, input, output, answer);
        input = 13;
        answer = 2;
        TEST(divisor_count, input, output, answer);
        input = 0;
        answer = 0;
        TEST(divisor_count, input, output, answer);
        input = -1;
        answer = 0;
        TEST(divisor_count, input, output, answer);
        input = 1;
        answer = 1;
        TEST(divisor_count, input, output, answer);
        input = 36;
        answer = 9;
        TEST(divisor_count, input, output, answer);
        
        // solution() test
        input = 2;
        answer = 6;
        TEST(solution, input, output, answer);
        input = 4;
        answer = 28;
        TEST(solution, input, output, answer);
        input = 5;
        answer = 28;
        TEST(solution, input, output, answer);
        input = 6;
        answer = 36;
        TEST(solution, input, output, answer);
        input = 8;
        answer = 36;
        TEST(solution, input, output, answer);
}

